/**
Робот на бесконечной плоскости XY стартует из точки (0, 0) лицом на север. Робот может получать последовательность этих трех возможных типов команд:
-2: Поверните налево на 90 градусов.
-1: Поверните направо на 90 градусов.
1 <= k <= 9: двигаться вперед на k единиц, по одной единице за раз.
Некоторые квадраты сетки являются препятствиями. i-е препятствие находится в точке сетки препятствия[i] = (xi, yi). Если робот натолкнется на препятствие, он останется на своем текущем месте и перейдет к следующей команде.
Возвращает максимальное евклидово расстояние, которое робот когда-либо проходит от начала координат, в квадрате (т. е. если расстояние равно 5, возвращает 25). 
 */

let commands = [4, -1, 4, -2, 4];
let obstacles = [[2, 4]];

let robotSim = function (commands, obstacles) {
    let x = 0;
    let y = 0;
    let directionIndex = 0; // индекс текущего направления (0: север, 1: восток, 2: юг, 3: запад)
    let ans = 0; // максимальное евклидово расстояние в квадрате

    // направления: север, восток, юг, запад
    let directions = [
        [0, 1],
        [1, 0],
        [0, -1],
        [-1, 0],
    ];

    // Преобразуем массив препятствий в set для быстрого поиска
    let obstacleSet = new Set(obstacles.map(obstacle => obstacle.join(',')));

    for (let command of commands) {
        if (command === -1) {
            // Поворот направо
            directionIndex = (directionIndex + 1) % 4;
        } else if (command === -2) {
            // Поворот налево
            directionIndex = (directionIndex + 3) % 4;
        } else {
            // Движение вперёд
            let [dx, dy] = directions[directionIndex];
            for (let i = 0; i < command; i++) {
                let nextX = x + dx;
                let nextY = y + dy;
                if (obstacleSet.has(`${nextX},${nextY}`)) {
                    // Если впереди препятствие, остановимся
                    break;
                }
                x = nextX;
                y = nextY;
                // Обновляем максимальное расстояние
                ans = Math.max(ans, x * x + y * y);
            }
        }
    }

    return ans;
};

console.log(robotSim(commands, obstacles));
